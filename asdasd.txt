 Mat3d[][] quatToMatrix(Vec4d q)
        {
            double sqw = q.W * q.W;
            double sqx = q.X * q.X;
            double sqy = q.Y * q.Y;
            double sqz = q.Z * q.Z;

            // invs (inverse square length) is only required if quaternion is not already normalised
            double invs = 1 / (sqx + sqy + sqz + sqw);

            Mat3d[][] m;

            m[0][0] = m.fr(sqx - sqy - sqz + sqw) * invs; // since sqw + sqx + sqy + sqz =1/invs*invs
            m[1][1] = (-sqx + sqy - sqz + sqw) * invs;
            m[2][2] = (-sqx - sqy + sqz + sqw) * invs;

            double tmp1 = q.x * q.y;
            double tmp2 = q.z * q.w;
            m[1][0] = 2.0 * (tmp1 + tmp2) * invs;
            m[0][1] = 2.0 * (tmp1 - tmp2) * invs;

            tmp1 = q.x * q.z;
            tmp2 = q.y * q.w;
            m[2][0] = 2.0 * (tmp1 - tmp2) * invs;
            m[0][2] = 2.0 * (tmp1 + tmp2) * invs;

            tmp1 = q.y * q.z;
            tmp2 = q.x * q.w;
            m[2][1] = 2.0 * (tmp1 + tmp2) * invs;
           m[1][2] = 2.0 * (tmp1 - tmp2) * invs;

           return m;
       }